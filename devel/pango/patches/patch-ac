$NetBSD: patch-ac,v 1.13 2009/11/25 09:58:39 tron Exp $

See https://bugzilla.gnome.org/show_bug.cgi?id=602408
and https://bugzilla.gnome.org/show_bug.cgi?id=602660

--- pango/opentype/hb-open-type-private.hh.orig
+++ pango/opentype/hb-open-type-private.hh
@@ -50,6 +50,9 @@
 #define CONST_NEXT(T,X)		(*(reinterpret_cast<const T *>(CONST_CHARP(&(X)) + (X).get_size ())))
 #define NEXT(T,X)		(*(reinterpret_cast<T *>(CHARP(&(X)) + (X).get_size ())))
 
+#define CONST_ARRAY_AFTER(T,X)	((reinterpret_cast<const T *>(CONST_CHARP(&(X)) + sizeof (X))))
+#define ARRAY_AFTER(T,X)	((reinterpret_cast<T *>(CHARP(&(X)) + sizeof (X))))
+
 /*
  * Class features
  */
@@ -58,7 +61,7 @@
 /* Null objects */
 
 /* Global nul-content Null pool.  Enlarge as necessary. */
-static const char NullPool[16] = "";
+static const char NullPool[32] = "";
 
 /* Generic template for nul-content sizeof-sized Null objects. */
 template <typename Type>
@@ -258,7 +258,7 @@ _hb_sanitize_edit (SANITIZE_ARG_DEF,
 #define NEUTER(Var, Val) \
 	(SANITIZE_OBJ (Var) && \
 	 _hb_sanitize_edit (SANITIZE_ARG, CONST_CHARP(&(Var)), sizeof (Var)) && \
-	 ((Var) = (Val), true))
+	 ((Var).set (Val), true))
 
 
 /* Template to sanitize an object. */
@@ -345,7 +345,7 @@ struct Sanitizer
 #define _DEFINE_INT_TYPE1_UNALIGNED(NAME, TYPE, BIG_ENDIAN, BYTES) \
   struct NAME \
   { \
-    inline NAME& operator = (TYPE i) { (TYPE&) v = BIG_ENDIAN (i); return *this; } \
+    inline NAME& set (TYPE i) { (TYPE&) v = BIG_ENDIAN (i); return *this; } \
     inline operator TYPE(void) const { return BIG_ENDIAN ((TYPE&) v); } \
     inline bool operator== (NAME o) const { return (TYPE&) v == (TYPE&) o.v; } \
     inline bool sanitize (SANITIZE_ARG_DEF) { \
@@ -359,7 +359,7 @@ struct Sanitizer
 #define DEFINE_INT_TYPE1(NAME, TYPE, BIG_ENDIAN, BYTES) \
   struct NAME \
   { \
-    inline NAME& operator = (TYPE i) { BIG_ENDIAN##_put_unaligned(v, i); return *this; } \
+    inline NAME& set (TYPE i) { BIG_ENDIAN##_put_unaligned(v, i); return *this; } \
     inline operator TYPE(void) const { return BIG_ENDIAN##_get_unaligned (v); } \
     inline bool operator== (NAME o) const { return BIG_ENDIAN##_cmp_unaligned (v, o.v); } \
     inline bool sanitize (SANITIZE_ARG_DEF) { \
@@ -384,7 +384,7 @@ DEFINE_INT_TYPE (LONG,	  , 32);	/* 32-bit signed integer. */
 struct Tag : ULONG
 {
   inline Tag (const Tag &o) { *(ULONG*)this = (ULONG&) o; }
-  inline Tag (uint32_t i) { *(ULONG*)this = i; }
+  inline Tag (uint32_t i) { (*(ULONG*)this).set (i); }
   inline Tag (const char *c) { *(ULONG*)this = *(ULONG*)c; }
   inline bool operator== (const char *c) const { return *(ULONG*)this == *(ULONG*)c; }
   /* What the char* converters return is NOT nul-terminated.  Print using "%.4s" */
@@ -505,13 +508,16 @@ struct LongOffsetTo : GenericOffsetTo<LongOffset, Type> {};
 template <typename LenType, typename Type>
 struct GenericArrayOf
 {
+  const Type *const_array(void) const { return CONST_ARRAY_AFTER (Type, len); }
+  Type *array(void) { return ARRAY_AFTER (Type, len); }
+
   inline const Type& operator [] (unsigned int i) const
   {
     if (HB_UNLIKELY (i >= len)) return Null(Type);
-    return array[i];
+    return const_array()[i];
   }
   inline unsigned int get_size () const
-  { return sizeof (len) + len * sizeof (array[0]); }
+  { return sizeof (len) + len * sizeof (Type); }
 
   inline bool sanitize (SANITIZE_ARG_DEF) {
     TRACE_SANITIZE ();
@@ -523,7 +529,7 @@ struct GenericArrayOf
     return true;
     unsigned int count = len;
     for (unsigned int i = 0; i < count; i++)
-      if (!SANITIZE (array[i]))
+      if (!SANITIZE (array()[i]))
         return false;
     return true;
   }
@@ -532,7 +538,7 @@ struct GenericArrayOf
     if (!SANITIZE_GET_SIZE()) return false;
     unsigned int count = len;
     for (unsigned int i = 0; i < count; i++)
-      if (!array[i].sanitize (SANITIZE_ARG, base))
+      if (!array()[i].sanitize (SANITIZE_ARG, base))
         return false;
     return true;
   }
@@ -541,7 +547,7 @@ struct GenericArrayOf
     if (!SANITIZE_GET_SIZE()) return false;
     unsigned int count = len;
     for (unsigned int i = 0; i < count; i++)
-      if (!array[i].sanitize (SANITIZE_ARG, base, base2))
+      if (!array()[i].sanitize (SANITIZE_ARG, base, base2))
         return false;
     return true;
   }
@@ -550,13 +556,13 @@ struct GenericArrayOf
     if (!SANITIZE_GET_SIZE()) return false;
     unsigned int count = len;
     for (unsigned int i = 0; i < count; i++)
-      if (!array[i].sanitize (SANITIZE_ARG, base, user_data))
+      if (!array()[i].sanitize (SANITIZE_ARG, base, user_data))
         return false;
     return true;
   }
 
   LenType len;
-  Type array[];
+/*Type array[VAR];*/
 };
 
 /* An array with a USHORT number of elements. */
@@ -586,7 +592,7 @@ struct OffsetListOf : OffsetArrayOf<Type>
   inline const Type& operator [] (unsigned int i) const
   {
     if (HB_UNLIKELY (i >= this->len)) return Null(Type);
-    return this+this->array[i];
+    return this+this->const_array()[i];
   }
 
   inline bool sanitize (SANITIZE_ARG_DEF) {
@@ -605,13 +611,16 @@ struct OffsetListOf : OffsetArrayOf<Type>
 template <typename Type>
 struct HeadlessArrayOf
 {
+  const Type *const_array(void) const { return CONST_ARRAY_AFTER (Type, len); }
+  Type *array(void) { return ARRAY_AFTER (Type, len); }
+
   inline const Type& operator [] (unsigned int i) const
   {
     if (HB_UNLIKELY (i >= len || !i)) return Null(Type);
-    return array[i-1];
+    return const_array()[i-1];
   }
   inline unsigned int get_size () const
-  { return sizeof (len) + (len ? len - 1 : 0) * sizeof (array[0]); }
+  { return sizeof (len) + (len ? len - 1 : 0) * sizeof (Type); }
 
   inline bool sanitize (SANITIZE_ARG_DEF) {
     TRACE_SANITIZE ();
@@ -622,14 +631,15 @@ struct HeadlessArrayOf
      * do have a simple sanitize(). */
     return true;
     unsigned int count = len ? len - 1 : 0;
+    Type *a = array();
     for (unsigned int i = 0; i < count; i++)
-      if (!SANITIZE (array[i]))
+      if (!SANITIZE (a[i]))
         return false;
     return true;
   }
 
   USHORT len;
-  Type array[];
+/*Type array[VAR];*/
 };
 
 
