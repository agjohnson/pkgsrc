Only in maplay.new: .extract_done
diff -c -r maplay/all.h maplay.new/all.h
*** maplay/all.h	Thu Jun 23 12:14:39 1994
--- maplay.new/all.h	Tue Feb 14 07:50:56 1995
***************
*** 22,28 ****
  #define ALL_H
  
  typedef float		real;		// float should be enough
! typedef short		bool;
  typedef unsigned	uint32;		// 32 Bit unsigned integer
  	// some compilers may need "typedef unsigned long uint32" instead
  typedef int		int32;		// 32 Bit signed integer
--- 22,28 ----
  #define ALL_H
  
  typedef float		real;		// float should be enough
! typedef short		boolean;
  typedef unsigned	uint32;		// 32 Bit unsigned integer
  	// some compilers may need "typedef unsigned long uint32" instead
  typedef int		int32;		// 32 Bit signed integer
diff -c -r maplay/configuration.sh maplay.new/configuration.sh
*** maplay/configuration.sh	Thu Jun 23 12:14:46 1994
--- maplay.new/configuration.sh	Tue Feb 14 07:46:52 1995
***************
*** 72,77 ****
--- 72,83 ----
       INCLUDEDIRS=
       LIBRARIES=
       AUDIO_INCLUDES='#include <sys/audioio.h>' ;;
+   FreeBSD*)
+      COMPILER=g++
+      COMPILERFLAGS='-O2 -m486 -DLINUX -DDAMN_INTEL_BYTE_ORDER'
+      INCLUDEDIRS=
+      LIBRARIES= 
+      AUDIO_INCLUDES='#include <machine/soundcard.h>' ;;
    Linux*)
       COMPILER=g++
       COMPILERFLAGS='-O2 -m486 -funroll-loops -DLINUX -DDAMN_INTEL_BYTE_ORDER'
diff -c -r maplay/header.cc maplay.new/header.cc
*** maplay/header.cc	Thu Jun 23 12:14:35 1994
--- maplay.new/header.cc	Tue Feb 14 07:52:56 1995
***************
*** 36,42 ****
  const uint32 Header::frequencies[3] = { 44100, 48000, 32000 };
  
  
! bool Header::read_header (Ibitstream *stream, Crc16 **crcp)
  {
    uint32 headerstring;
  
--- 36,42 ----
  const uint32 Header::frequencies[3] = { 44100, 48000, 32000 };
  
  
! boolean Header::read_header (Ibitstream *stream, Crc16 **crcp)
  {
    uint32 headerstring;
  
diff -c -r maplay/header.h maplay.new/header.h
*** maplay/header.h	Thu Jun 23 12:14:40 1994
--- maplay.new/header.h	Tue Feb 14 07:52:57 1995
***************
*** 39,45 ****
    e_mode		h_mode;
    e_sample_frequency	h_sample_frequency;
    uint32		h_number_of_subbands, h_intensity_stereo_bound;
!   bool			h_copyright, h_original;
    Crc16			*crc;
    uint16		checksum;
  
--- 39,45 ----
    e_mode		h_mode;
    e_sample_frequency	h_sample_frequency;
    uint32		h_number_of_subbands, h_intensity_stereo_bound;
!   boolean			h_copyright, h_original;
    Crc16			*crc;
    uint16		checksum;
  
***************
*** 48,54 ****
  public:
  			Header (void) { crc = (Crc16 *)0; }
  		       ~Header (void) { if (crc) delete crc; }
!   bool			read_header (Ibitstream *, Crc16 **);
  			// read a 32-bit header from the bitstream
  
    // functions to query header contents:
--- 48,54 ----
  public:
  			Header (void) { crc = (Crc16 *)0; }
  		       ~Header (void) { if (crc) delete crc; }
!   boolean			read_header (Ibitstream *, Crc16 **);
  			// read a 32-bit header from the bitstream
  
    // functions to query header contents:
***************
*** 58,68 ****
    uint32		frequency (void) { return frequencies[h_sample_frequency]; }
    static uint32	frequency (e_sample_frequency rate) { return frequencies[rate]; }
    e_mode		mode (void) { return h_mode; };
!   bool			checksums (void) { return !h_protection_bit; }
!   bool			copyright (void) { return h_copyright; }
!   bool			original (void) { return h_original; }
  
!   bool			checksum_ok (void) { return checksum == crc->checksum (); }
  			// compares computed checksum with stream checksum
  
    // functions which return header informations as strings:
--- 58,68 ----
    uint32		frequency (void) { return frequencies[h_sample_frequency]; }
    static uint32	frequency (e_sample_frequency rate) { return frequencies[rate]; }
    e_mode		mode (void) { return h_mode; };
!   boolean			checksums (void) { return !h_protection_bit; }
!   boolean			copyright (void) { return h_copyright; }
!   boolean			original (void) { return h_original; }
  
!   boolean			checksum_ok (void) { return checksum == crc->checksum (); }
  			// compares computed checksum with stream checksum
  
    // functions which return header informations as strings:
diff -c -r maplay/ibitstream.cc maplay.new/ibitstream.cc
*** maplay/ibitstream.cc	Thu Jun 23 12:14:35 1994
--- maplay.new/ibitstream.cc	Tue Feb 14 07:52:56 1995
***************
*** 64,70 ****
  }
  
  
! bool Ibitstream::get_header (uint32 *headerstring)
  {
    int readvalue;
  
--- 64,70 ----
  }
  
  
! boolean Ibitstream::get_header (uint32 *headerstring)
  {
    int readvalue;
  
***************
*** 102,108 ****
  }
  
  
! bool Ibitstream::read_frame (uint32 bytesize)
  {
    int readvalue;
  
--- 102,108 ----
  }
  
  
! boolean Ibitstream::read_frame (uint32 bytesize)
  {
    int readvalue;
  
diff -c -r maplay/ibitstream.h maplay.new/ibitstream.h
*** maplay/ibitstream.h	Thu Jun 23 12:14:40 1994
--- maplay.new/ibitstream.h	Tue Feb 14 07:52:58 1995
***************
*** 43,52 ****
  		~Ibitstream (void);
    int		filedescriptor (void) { return fd; };
  
!   bool		get_header (uint32 *);
  		// get next 32 bits from bitstream in an unsigned int,
  		// returned value False => end of stream
!   bool		read_frame (uint32 bytesize);
  		// fill buffer with data from bitstream, returned value False => end of stream
    uint32	get_bits (uint32 number_of_bits);
  		// read bits (1 <= number_of_bits <= 16) from buffer into the lower bits
--- 43,52 ----
  		~Ibitstream (void);
    int		filedescriptor (void) { return fd; };
  
!   boolean		get_header (uint32 *);
  		// get next 32 bits from bitstream in an unsigned int,
  		// returned value False => end of stream
!   boolean		read_frame (uint32 bytesize);
  		// fill buffer with data from bitstream, returned value False => end of stream
    uint32	get_bits (uint32 number_of_bits);
  		// read bits (1 <= number_of_bits <= 16) from buffer into the lower bits
diff -c -r maplay/maplay.cc maplay.new/maplay.cc
*** maplay/maplay.cc	Thu Jun 23 12:14:36 1994
--- maplay.new/maplay.cc	Tue Feb 14 07:52:57 1995
***************
*** 54,67 ****
  
  // data extracted from commandline arguments:
  static char *filename;
! static bool verbose_mode = False, filter_check = False;
! static bool stdout_mode = False;
  static enum e_channels which_channels = both;
! static bool use_speaker = False, use_headphone = False, use_line_out = False;
  #ifdef ULAW
! static bool force_amd = False;
  #endif
! static bool use_own_scalefactor = False;
  static real scalefactor;
  
  // data extracted from header of first frame:
--- 54,67 ----
  
  // data extracted from commandline arguments:
  static char *filename;
! static boolean verbose_mode = False, filter_check = False;
! static boolean stdout_mode = False;
  static enum e_channels which_channels = both;
! static boolean use_speaker = False, use_headphone = False, use_line_out = False;
  #ifdef ULAW
! static boolean force_amd = False;
  #endif
! static boolean use_own_scalefactor = False;
  static real scalefactor;
  
  // data extracted from header of first frame:
***************
*** 93,99 ****
  main (int argc, char *argv[])
  {
    int i;
!   bool read_ready = False, write_ready = False;
  
    if (argc < 2 || !strncmp (argv[1], "-h", 2))
    {
--- 93,99 ----
  main (int argc, char *argv[])
  {
    int i;
!   boolean read_ready = False, write_ready = False;
  
    if (argc < 2 || !strncmp (argv[1], "-h", 2))
    {
***************
*** 146,151 ****
--- 146,154 ----
  #ifdef Solaris
  	    "SPARC Solaris 2.x"
  #else
+ #ifdef __FreeBSD__
+ 	    "FreeBSD"
+ #else
  #ifdef LINUX
  	    "Linux"
  #else
***************
*** 153,158 ****
--- 156,162 ----
  	    "RISC ULTRIX 4.x"
  #else
  	    "unknown"
+ #endif
  #endif
  #endif
  #endif
diff -c -r maplay/obuffer.cc maplay.new/obuffer.cc
*** maplay/obuffer.cc	Thu Jun 23 12:14:36 1994
--- maplay.new/obuffer.cc	Tue Feb 14 07:52:57 1995
***************
*** 217,226 ****
  int SparcObuffer::audio_fd = -1;
  
  #ifdef ULAW
! SparcObuffer::SparcObuffer (Header *header, bool use_speaker, bool use_headphone, bool use_line_out)
  #else
  SparcObuffer::SparcObuffer (uint32 number_of_channels, Header *header,
! 			    bool use_speaker, bool use_headphone, bool use_line_out)
  #endif
  {
  #ifndef ULAW
--- 217,226 ----
  int SparcObuffer::audio_fd = -1;
  
  #ifdef ULAW
! SparcObuffer::SparcObuffer (Header *header, boolean use_speaker, boolean use_headphone, boolean use_line_out)
  #else
  SparcObuffer::SparcObuffer (uint32 number_of_channels, Header *header,
! 			    boolean use_speaker, boolean use_headphone, boolean use_line_out)
  #endif
  {
  #ifndef ULAW
***************
*** 406,414 ****
  
  
  #ifdef ULAW
! bool SparcObuffer::class_suitable (uint32 number_of_channels, bool force_amd)
  #else
! bool SparcObuffer::class_suitable (void)
  #endif
  {
  #ifdef ULAW
--- 406,414 ----
  
  
  #ifdef ULAW
! boolean SparcObuffer::class_suitable (uint32 number_of_channels, boolean force_amd)
  #else
! boolean SparcObuffer::class_suitable (void)
  #endif
  {
  #ifdef ULAW
***************
*** 629,635 ****
  }
  
  
! bool LinuxObuffer::class_suitable (uint32 number_of_channels)
  {
    // open the dsp audio device:
    audio_fd = open_audio_device ();
--- 629,635 ----
  }
  
  
! boolean LinuxObuffer::class_suitable (uint32 number_of_channels)
  {
    // open the dsp audio device:
    audio_fd = open_audio_device ();
diff -c -r maplay/obuffer.h maplay.new/obuffer.h
*** maplay/obuffer.h	Thu Jun 23 12:14:40 1994
--- maplay.new/obuffer.h	Tue Feb 14 07:52:58 1995
***************
*** 123,142 ****
  
  public:
  #ifdef ULAW
! 	SparcObuffer (Header *, bool use_speaker, bool use_headphone, bool use_line_out);
  #else
  	SparcObuffer (uint32 number_of_channels, Header *,
!  		      bool use_speaker, bool use_headphone, bool use_line_out);
  #endif
         ~SparcObuffer (void);
    void	append (uint32 channel, int16 value);
    void	write_buffer (int dummy);
  
  #ifdef ULAW
!   static bool class_suitable (uint32 number_of_channels, bool force_amd);
  	// returnvalue == False: no u-law output possible (class unsuitable)
  #else
!   static bool class_suitable (void);
  	// returnvalue == False: no 16-bit output possible (class unsuitable)
  #endif
  };
--- 123,142 ----
  
  public:
  #ifdef ULAW
! 	SparcObuffer (Header *, boolean use_speaker, boolean use_headphone, boolean use_line_out);
  #else
  	SparcObuffer (uint32 number_of_channels, Header *,
!  		      boolean use_speaker, boolean use_headphone, boolean use_line_out);
  #endif
         ~SparcObuffer (void);
    void	append (uint32 channel, int16 value);
    void	write_buffer (int dummy);
  
  #ifdef ULAW
!   static boolean class_suitable (uint32 number_of_channels, boolean force_amd);
  	// returnvalue == False: no u-law output possible (class unsuitable)
  #else
!   static boolean class_suitable (void);
  	// returnvalue == False: no 16-bit output possible (class unsuitable)
  #endif
  };
***************
*** 159,165 ****
    void	append (uint32 channel, int16 value);
    void	write_buffer (int dummy);
  
!   static bool class_suitable (uint32 number_of_channels);
  };
  #endif	// LINUX
  
--- 159,165 ----
    void	append (uint32 channel, int16 value);
    void	write_buffer (int dummy);
  
!   static boolean class_suitable (uint32 number_of_channels);
  };
  #endif	// LINUX
  
diff -c -r maplay/subband.h maplay.new/subband.h
*** maplay/subband.h	Thu Jun 23 12:14:40 1994
--- maplay.new/subband.h	Tue Feb 14 07:52:58 1995
***************
*** 35,42 ****
  public:
    virtual void read_allocation (Ibitstream *, Header *, Crc16 *) = 0;
    virtual void read_scalefactor (Ibitstream *, Header *) = 0;
!   virtual bool read_sampledata (Ibitstream *) = 0;
!   virtual bool put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *) = 0;
  };
  
  #endif
--- 35,42 ----
  public:
    virtual void read_allocation (Ibitstream *, Header *, Crc16 *) = 0;
    virtual void read_scalefactor (Ibitstream *, Header *) = 0;
!   virtual boolean read_sampledata (Ibitstream *) = 0;
!   virtual boolean put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *) = 0;
  };
  
  #endif
diff -c -r maplay/subband_layer_1.cc maplay.new/subband_layer_1.cc
*** maplay/subband_layer_1.cc	Thu Jun 23 12:14:36 1994
--- maplay.new/subband_layer_1.cc	Tue Feb 14 07:52:57 1995
***************
*** 86,92 ****
  }
  
  
! bool SubbandLayer1::read_sampledata (Ibitstream *stream)
  {
    if (allocation)
    {
--- 86,92 ----
  }
  
  
! boolean SubbandLayer1::read_sampledata (Ibitstream *stream)
  {
    if (allocation)
    {
***************
*** 105,111 ****
  }
  
  
! bool SubbandLayer1::put_next_sample (e_channels channels,
  				     SynthesisFilter *filter1, SynthesisFilter *)
  {
    if (allocation && channels != right)
--- 105,111 ----
  }
  
  
! boolean SubbandLayer1::put_next_sample (e_channels channels,
  				     SynthesisFilter *filter1, SynthesisFilter *)
  {
    if (allocation && channels != right)
***************
*** 142,148 ****
  }
  
  
! bool SubbandLayer1IntensityStereo::put_next_sample (e_channels channels,
  	SynthesisFilter *filter1, SynthesisFilter *filter2)
  {
    if (allocation)
--- 142,148 ----
  }
  
  
! boolean SubbandLayer1IntensityStereo::put_next_sample (e_channels channels,
  	SynthesisFilter *filter1, SynthesisFilter *filter2)
  {
    if (allocation)
***************
*** 231,239 ****
  }
  
  
! bool SubbandLayer1Stereo::read_sampledata (Ibitstream *stream)
  {
!   bool returnvalue = SubbandLayer1::read_sampledata (stream);
    if (channel2_allocation)
    {
      channel2_sample = real (stream->get_bits (channel2_samplelength));
--- 231,239 ----
  }
  
  
! boolean SubbandLayer1Stereo::read_sampledata (Ibitstream *stream)
  {
!   boolean returnvalue = SubbandLayer1::read_sampledata (stream);
    if (channel2_allocation)
    {
      channel2_sample = real (stream->get_bits (channel2_samplelength));
***************
*** 246,252 ****
  }
  
  
! bool SubbandLayer1Stereo::put_next_sample (e_channels channels,
  					   SynthesisFilter *filter1, SynthesisFilter *filter2)
  {
    SubbandLayer1::put_next_sample (channels, filter1, filter2);
--- 246,252 ----
  }
  
  
! boolean SubbandLayer1Stereo::put_next_sample (e_channels channels,
  					   SynthesisFilter *filter1, SynthesisFilter *filter2)
  {
    SubbandLayer1::put_next_sample (channels, filter1, filter2);
diff -c -r maplay/subband_layer_1.h maplay.new/subband_layer_1.h
*** maplay/subband_layer_1.h	Thu Jun 23 12:14:40 1994
--- maplay.new/subband_layer_1.h	Tue Feb 14 07:52:58 1995
***************
*** 42,49 ****
         SubbandLayer1 (uint32 subbandnumber);
    void read_allocation (Ibitstream *, Header *, Crc16 *);
    void read_scalefactor (Ibitstream *, Header *);
!   bool read_sampledata (Ibitstream *);
!   bool put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  
--- 42,49 ----
         SubbandLayer1 (uint32 subbandnumber);
    void read_allocation (Ibitstream *, Header *, Crc16 *);
    void read_scalefactor (Ibitstream *, Header *);
!   boolean read_sampledata (Ibitstream *);
!   boolean put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  
***************
*** 60,70 ****
      SubbandLayer1::read_allocation (stream, header, crc);
    }
    void read_scalefactor (Ibitstream *, Header *);
!   bool read_sampledata (Ibitstream *stream)
    {
      return SubbandLayer1::read_sampledata (stream);
    }
!   bool put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  
--- 60,70 ----
      SubbandLayer1::read_allocation (stream, header, crc);
    }
    void read_scalefactor (Ibitstream *, Header *);
!   boolean read_sampledata (Ibitstream *stream)
    {
      return SubbandLayer1::read_sampledata (stream);
    }
!   boolean put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  
***************
*** 82,89 ****
         SubbandLayer1Stereo (uint32 subbandnumber);
    void read_allocation (Ibitstream *, Header *, Crc16 *);
    void read_scalefactor (Ibitstream *, Header *);
!   bool read_sampledata (Ibitstream *);
!   bool put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  #endif
--- 82,89 ----
         SubbandLayer1Stereo (uint32 subbandnumber);
    void read_allocation (Ibitstream *, Header *, Crc16 *);
    void read_scalefactor (Ibitstream *, Header *);
!   boolean read_sampledata (Ibitstream *);
!   boolean put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  #endif
diff -c -r maplay/subband_layer_2.cc maplay.new/subband_layer_2.cc
*** maplay/subband_layer_2.cc	Thu Jun 23 12:14:36 1994
--- maplay.new/subband_layer_2.cc	Tue Feb 14 07:52:57 1995
***************
*** 591,597 ****
  }
  
  
! bool SubbandLayer2::read_sampledata (Ibitstream *stream)
  {
    if (allocation)
      if (groupingtable)
--- 591,597 ----
  }
  
  
! boolean SubbandLayer2::read_sampledata (Ibitstream *stream)
  {
    if (allocation)
      if (groupingtable)
***************
*** 633,639 ****
  }
  
  
! bool SubbandLayer2::put_next_sample (e_channels channels,
  				     SynthesisFilter *filter1, SynthesisFilter *)
  {
  #ifdef DEBUG
--- 633,639 ----
  }
  
  
! boolean SubbandLayer2::put_next_sample (e_channels channels,
  				     SynthesisFilter *filter1, SynthesisFilter *)
  {
  #ifdef DEBUG
***************
*** 726,732 ****
  }
  
  
! bool SubbandLayer2IntensityStereo::put_next_sample (e_channels channels,
  	SynthesisFilter *filter1, SynthesisFilter *filter2)
  {
  #ifdef DEBUG
--- 726,732 ----
  }
  
  
! boolean SubbandLayer2IntensityStereo::put_next_sample (e_channels channels,
  	SynthesisFilter *filter1, SynthesisFilter *filter2)
  {
  #ifdef DEBUG
***************
*** 880,888 ****
  }
  
  
! bool SubbandLayer2Stereo::read_sampledata (Ibitstream *stream)
  {
!   bool returnvalue = SubbandLayer2::read_sampledata (stream);
  
    if (channel2_allocation)
      if (channel2_groupingtable)
--- 880,888 ----
  }
  
  
! boolean SubbandLayer2Stereo::read_sampledata (Ibitstream *stream)
  {
!   boolean returnvalue = SubbandLayer2::read_sampledata (stream);
  
    if (channel2_allocation)
      if (channel2_groupingtable)
***************
*** 919,928 ****
  }
  
  
! bool SubbandLayer2Stereo::put_next_sample (e_channels channels,
  					   SynthesisFilter *filter1, SynthesisFilter *filter2)
  {
!   bool returnvalue = SubbandLayer2::put_next_sample (channels, filter1, filter2);
    if (channel2_allocation && channels != left)
    {
      register real sample = channel2_samples[samplenumber - 1];
--- 919,928 ----
  }
  
  
! boolean SubbandLayer2Stereo::put_next_sample (e_channels channels,
  					   SynthesisFilter *filter1, SynthesisFilter *filter2)
  {
!   boolean returnvalue = SubbandLayer2::put_next_sample (channels, filter1, filter2);
    if (channel2_allocation && channels != left)
    {
      register real sample = channel2_samples[samplenumber - 1];
diff -c -r maplay/subband_layer_2.h maplay.new/subband_layer_2.h
*** maplay/subband_layer_2.h	Thu Jun 23 12:14:40 1994
--- maplay.new/subband_layer_2.h	Tue Feb 14 07:52:58 1995
***************
*** 55,62 ****
    void		read_allocation (Ibitstream *, Header *, Crc16 *);
    virtual void	read_scalefactor_selection (Ibitstream *, Crc16 *);
    void		read_scalefactor (Ibitstream *, Header *);
!   bool		read_sampledata (Ibitstream *);
!   bool		put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter * = NULL);
  };
  
  
--- 55,62 ----
    void		read_allocation (Ibitstream *, Header *, Crc16 *);
    virtual void	read_scalefactor_selection (Ibitstream *, Crc16 *);
    void		read_scalefactor (Ibitstream *, Header *);
!   boolean		read_sampledata (Ibitstream *);
!   boolean		put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter * = NULL);
  };
  
  
***************
*** 75,85 ****
    }
    void read_scalefactor_selection (Ibitstream *, Crc16 *);
    void read_scalefactor (Ibitstream *, Header *);
!   bool read_sampledata (Ibitstream *stream)
    {
      return SubbandLayer2::read_sampledata (stream);
    }
!   bool put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  
--- 75,85 ----
    }
    void read_scalefactor_selection (Ibitstream *, Crc16 *);
    void read_scalefactor (Ibitstream *, Header *);
!   boolean read_sampledata (Ibitstream *stream)
    {
      return SubbandLayer2::read_sampledata (stream);
    }
!   boolean put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  
***************
*** 90,96 ****
    uint32 channel2_allocation;
    uint32 channel2_scfsi;
    real	 channel2_scalefactor1, channel2_scalefactor2, channel2_scalefactor3;
!   bool	 channel2_grouping;
    uint32 channel2_codelength;
    const real *channel2_groupingtable;
    real	 channel2_factor;
--- 90,96 ----
    uint32 channel2_allocation;
    uint32 channel2_scfsi;
    real	 channel2_scalefactor1, channel2_scalefactor2, channel2_scalefactor3;
!   boolean	 channel2_grouping;
    uint32 channel2_codelength;
    const real *channel2_groupingtable;
    real	 channel2_factor;
***************
*** 102,109 ****
    void read_allocation (Ibitstream *, Header *, Crc16 *);
    void read_scalefactor_selection (Ibitstream *, Crc16 *);
    void read_scalefactor (Ibitstream *, Header *);
!   bool read_sampledata (Ibitstream *);
!   bool put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  #endif
--- 102,109 ----
    void read_allocation (Ibitstream *, Header *, Crc16 *);
    void read_scalefactor_selection (Ibitstream *, Crc16 *);
    void read_scalefactor (Ibitstream *, Header *);
!   boolean read_sampledata (Ibitstream *);
!   boolean put_next_sample (e_channels, SynthesisFilter *, SynthesisFilter *);
  };
  
  #endif
